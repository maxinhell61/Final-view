models.py 

from flask_sqlalchemy import SQLAlchemy
from datetime import datetime, date

db = SQLAlchemy()



# User Model 
class User(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    phone = db.Column(db.String(15), unique=True, nullable=False)
    password = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(20), nullable=False, default="user") # user, admin, runner
    is_active = db.Column(db.Boolean, nullable=False, default=True)  # true- is active, false is inactive
    
    addresses = db.relationship('Address', backref='user', lazy=True)
    orders = db.relationship('Order', backref='user', lazy=True)
    carts = db.relationship('Cart', backref='user', lazy=True)
    runner_assignments = db.relationship('RunnerAssignments', backref='runner', lazy=True, 
                                         foreign_keys='RunnerAssignments.runner_id')




class Address(db.Model):
    __tablename__ = 'address'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    street = db.Column(db.String(255), nullable=False)
    city = db.Column(db.String(100), nullable=False)
    state = db.Column(db.String(100), nullable=False)
    zip_code = db.Column(db.String(20), nullable=False)
    country = db.Column(db.String(100), nullable=False)

# Product Model
class Product(db.Model):

    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255), nullable=False)
    description = db.Column(db.Text, nullable=True)
    price = db.Column(db.Float, nullable=False)
    unit = db.Column(db.String(50), nullable=False)
    stock = db.Column(db.Integer, nullable=False, default=0)
    category = db.Column(db.String(100), nullable=False)
    image_url = db.Column(db.String(255), nullable=True)
    
    def to_dict(self):
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "category": self.category,
            "price": self.price,
            "unit": self.unit,
            "stock": self.stock,
            "image_url": self.image_url or ""
        }


# Cart Model 
class Cart(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False, default=1)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    product = db.relationship('Product', backref=db.backref('carts', lazy=True))

# Order Model
class Order(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    total_price = db.Column(db.Float, nullable=False)
    status = db.Column(db.String(50), default="Pending")  # Pending, Processing, Out_for_delivery, Delivered, Cancelled
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # Relationships with related tables
    order_items = db.relationship('OrderItems', backref='order', lazy=True)
    payments = db.relationship('Payments', backref='order', lazy=True)
    runner_assignments = db.relationship('RunnerAssignments', backref='order', lazy=True)
    delivery_analytics = db.relationship('DeliveryAnalytics', backref='order', lazy=True, uselist=False)
    status_history = db.relationship('OrderStatusHistory', backref='order', lazy=True)

# Inventory Model 
class Inventory(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    stock = db.Column(db.Integer, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    product = db.relationship('Product', backref=db.backref('inventory', lazy=True))

# OrderItems Model (each record represents an item in an order)


class OrderItems(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    quantity = db.Column(db.Integer, nullable=False)
    price_at_order_time = db.Column(db.Float, nullable=False)
    
    product = db.relationship('Product', backref=db.backref('order_items', lazy=True))

# RunnerAssignments Model 
class RunnerAssignments(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    runner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    assigned_at = db.Column(db.DateTime, default=datetime.utcnow)
    picked_up_at = db.Column(db.DateTime, nullable=True)
    delivered_at = db.Column(db.DateTime, nullable=True)
    status = db.Column(db.String(50), default="assigned")  # assigned, picked_up, delivered, cancelled

# Payments Model (tracks payment details for an order)
class Payments(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    payment_method = db.Column(db.String(30), nullable=False)
    transaction_id = db.Column(db.String(100), nullable=False)
    status = db.Column(db.String(20), nullable=False, default="pending")  # success, failed, pending
    paid_at = db.Column(db.DateTime, nullable=True)

# RunnerLocation Model (stores the current location of a runner/delivery agent)
class RunnerLocation(db.Model):
    
    runner_id = db.Column(db.Integer, db.ForeignKey('user.id'), primary_key=True)
    latitude = db.Column(db.Float, nullable=False)
    longitude = db.Column(db.Float, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    runner = db.relationship('User', backref=db.backref('runner_location', uselist=False))

























# ===============================
# Analytics Models
# ===============================

# DeliveryAnalytics Model (tracks delivery time metrics for each order)
class DeliveryAnalytics(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), unique=True, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
    runner_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    order_placed_at = db.Column(db.DateTime, nullable=False)
    order_picked_at = db.Column(db.DateTime, nullable=True)
    order_delivered_at = db.Column(db.DateTime, nullable=True)
 ###########################   # Track metrics such as product views, cart abandonment rates, and average cart size to optimize product offerings and user experience.
    @property
    def delivery_duration_minutes(self):
        if self.order_delivered_at and self.order_placed_at:
            return int((self.order_delivered_at - self.order_placed_at).total_seconds() / 60)
        return None

# OrderStatusHistory Model (logs every change in an order's status)
class OrderStatusHistory(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    old_status = db.Column(db.String(50), nullable=False)
    new_status = db.Column(db.String(50), nullable=False)
    changed_at = db.Column(db.DateTime, default=datetime.utcnow)

# ProductViews Model (tracks when a product is viewed by a user)
class ProductViews(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=True)
    viewed_at = db.Column(db.DateTime, default=datetime.utcnow)

# ProductSales Model (aggregates daily sales data for each product)
class ProductSales(db.Model):
    
    id = db.Column(db.Integer, primary_key=True)
    product_id = db.Column(db.Integer, db.ForeignKey('product.id'), nullable=False)
    quantity_sold = db.Column(db.Integer, nullable=False)
    total_revenue = db.Column(db.Float, nullable=False)
    recorded_on = db.Column(db.Date, default=date.today)




----------------------------------

order.py 
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from datetime import datetime
from app import db
from app.models import User, Product, Cart, Order, OrderItems, Address,Inventory

order_bp = Blueprint("order", __name__)




@order_bp.route("/place", methods=["POST"])
@jwt_required()
def place_order():
    user_id = get_jwt_identity()
    data = request.get_json()

    # Check required fields
    if not data or "address_id" not in data or "payment_mode" not in data:
        return jsonify({"error": "Missing address or payment mode"}), 400

    # Normalize payment_mode
    payment_mode = data["payment_mode"].strip().lower()

    # Validate address ownership
    address = Address.query.filter_by(id=data["address_id"], user_id=user_id).first()
    if not address:
        return jsonify({"error": "Invalid or unauthorized address"}), 400

    # Fetch cart items
    cart_items = Cart.query.filter_by(user_id=user_id).all()
    if not cart_items:
        return jsonify({"error": "Cart is empty"}), 400

    total_price = 0
    order_item_objects = []

    # Validate stock and calculate total
    for item in cart_items:
        product = Product.query.get(item.product_id)
        if not product:
            return jsonify({"error": f"Product not found for ID {item.product_id}"}), 404

        if product.stock < item.quantity:
            return jsonify({"error": f"Insufficient stock for '{product.name}'"}), 400

        total_price += product.price * item.quantity
        order_item_objects.append({
            "product_id": product.id,
            "quantity": item.quantity,
            "price": product.price
        })

    # Create order with appropriate status
    new_order = Order(
        user_id=user_id,
        total_price=total_price,
        status="Pending" if payment_mode == "cod" else "Paid",
        created_at=datetime.utcnow()
    )
    db.session.add(new_order)
    db.session.flush()  # Get order.id before creating items

    # Add order items and update inventory
    for item in order_item_objects:
        db.session.add(OrderItems(
            order_id=new_order.id,
            product_id=item["product_id"],
            quantity=item["quantity"],
            price_at_order_time=item["price"]
        ))

        # Deduct from Product stock
        product = Product.query.get(item["product_id"])
        product.stock -= item["quantity"]

        # Deduct from Inventory if present
        inventory = Inventory.query.filter_by(product_id=product.id).first()
        if inventory:
            inventory.stock -= item["quantity"]
            inventory.updated_at = datetime.utcnow()

    # Clear user's cart
    Cart.query.filter_by(user_id=user_id).delete()

    db.session.commit()

    return jsonify({
        "message": "Order placed successfully",
        "order_id": new_order.id,
        "status": new_order.status,
        "total_price": total_price
    }), 201


# {
#   "address_id": 2,
#   "payment_mode": "cod"
# }

# curl --location 'http://127.0.0.1:5000/place' \
# --data '{
#   "address_id": 2,
#   "payment_mode": "cod"
# }'



# note:- 
# Make sure:

# Address exists and belongs to user

# Cart has items

# Enough stock exists












@order_bp.route("/userorder", methods=["GET"])
@jwt_required()
def get_user_orders():
    user_id = get_jwt_identity()
    orders = Order.query.filter_by(user_id=user_id).order_by(Order.created_at.desc()).all()
    return jsonify([{
        "order_id": order.id,
        "total_price": order.total_price,
        "status": order.status,
        "created_at": order.created_at.isoformat()
    } for order in orders]), 200

# http://127.0.0.1:5000/userorder

# curl --location 'http://127.0.0.1:5000/userorder' \
# --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc0NDgxNDY1OCwianRpIjoiN2NmNTNhMWUtYzMzOC00NzFjLWJiYjYtYTg3YWVhNDY4NTMzIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjciLCJuYmYiOjE3NDQ4MTQ2NTgsImNzcmYiOiIyYWFkZGM4YS04YjNmLTRkM2UtOTAxMS1hOTliMTMxYTgwOTgiLCJleHAiOjE3NDQ5MDEwNTh9.PfF2OSWLlTHkb3wNHi1KiF3lx0TB2yr1J55Wtv_bZ5s'


# [
#     {
#         "created_at": "2025-04-16T14:49:03",
#         "order_id": 3,
#         "status": "Pending",
#         "total_price": 1180.0
#     },
#     {
#         "created_at": "2025-04-16T14:45:33",
#         "order_id": 2,
#         "status": "Pending",
#         "total_price": 735.0
#     }
# ]



@order_bp.route("/order_details/<int:order_id>", methods=["GET"])
@jwt_required()
def get_order_details(order_id):
    user_id = get_jwt_identity()
    order = Order.query.filter_by(id=order_id, user_id=user_id).first()

    if not order:
        return jsonify({"error": "Order not found"}), 404

    items = [{
        "product_id": item.product_id,
        "product_name": item.product.name,
        "quantity": item.quantity,
        "unit_price": item.price_at_order_time
    } for item in order.order_items]

    return jsonify({
        "order_id": order.id,
        "total_price": order.total_price,
        "status": order.status,
        "created_at": order.created_at.isoformat(),
        "items": items
    }), 200

# http://127.0.0.1:5000/order_details/2

# curl --location 'http://127.0.0.1:5000/order_details/2' \
# --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc0NDg3OTczNSwianRpIjoiOWU4Y2I4ZDQtYzE2Mi00YzJjLWJmOWQtZWNjMzM2ZDIzYjQ2IiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjciLCJuYmYiOjE3NDQ4Nzk3MzUsImNzcmYiOiJhMGRiNmQxMy00ODRiLTQ1ZTMtYTc2My04NDJhMDQ4NTNmZmYiLCJleHAiOjE3NDQ5NjYxMzV9.12gKQbZuEmTmDZAE18JDW3AfX8LsZDyZY5IOpg00jFw'



@order_bp.route("/cancel/<int:order_id>", methods=["DELETE"])
@jwt_required()
def cancel_order(order_id):
    user_id = get_jwt_identity()
    order = Order.query.filter_by(id=order_id, user_id=user_id).first()

    if not order:
        return jsonify({"error": "Order not found"}), 404

    if order.status != "Pending":
        return jsonify({"error": "Only pending orders can be canceled"}), 400

    order.status = "Cancelled"
    db.session.commit()

    return jsonify({"message": "Order cancelled successfully"}), 200

# http://127.0.0.1:5000/order/cancel/1

# curl --location --request DELETE 'http://127.0.0.1:5000/order/cancel/1' \
# --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc0NDg3OTczNSwianRpIjoiOWU4Y2I4ZDQtYzE2Mi00YzJjLWJmOWQtZWNjMzM2ZDIzYjQ2IiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjciLCJuYmYiOjE3NDQ4Nzk3MzUsImNzcmYiOiJhMGRiNmQxMy00ODRiLTQ1ZTMtYTc2My04NDJhMDQ4NTNmZmYiLCJleHAiOjE3NDQ5NjYxMzV9.12gKQbZuEmTmDZAE18JDW3AfX8LsZDyZY5IOpg00jFw'


@order_bp.route("/track/<int:order_id>", methods=["GET"])
@jwt_required()
def track_order_status(order_id):
    user_id = get_jwt_identity()
    order = Order.query.filter_by(id=order_id, user_id=user_id).first()

    if not order:
        return jsonify({"error": "Order not found"}), 404

    return jsonify({"order_id": order.id, "status": order.status}), 200


# http://127.0.0.1:5000/track/2

# curl --location 'http://127.0.0.1:5000/track/2' \
# --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc0NDg3OTczNSwianRpIjoiOWU4Y2I4ZDQtYzE2Mi00YzJjLWJmOWQtZWNjMzM2ZDIzYjQ2IiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjciLCJuYmYiOjE3NDQ4Nzk3MzUsImNzcmYiOiJhMGRiNmQxMy00ODRiLTQ1ZTMtYTc2My04NDJhMDQ4NTNmZmYiLCJleHAiOjE3NDQ5NjYxMzV9.12gKQbZuEmTmDZAE18JDW3AfX8LsZDyZY5IOpg00jFw'




@order_bp.route("/return/<int:order_id>", methods=["POST"])
@jwt_required()
def return_order(order_id):
    user_id = get_jwt_identity()
    order = Order.query.filter_by(id=order_id, user_id=user_id).first()

    if not order:
        return jsonify({"error": "Order not found"}), 404

    if order.status != "Delivered":
        return jsonify({"error": "Only delivered orders can be returned"}), 400

    order.status = "Returned"
    db.session.commit()

    return jsonify({"message": "Order returned successfully"}), 200






@order_bp.route("/get_all_orders", methods=["GET"])
@jwt_required()
def get_all_orders():
    user_id = get_jwt_identity()
    user = User.query.get(user_id)

    if user.role != "admin":
        return jsonify({"error": "Unauthorized"}), 403

    orders = Order.query.order_by(Order.created_at.desc()).all()
    return jsonify([{
        "order_id": order.id,
        "user": order.user.name,
        "total_price": order.total_price,
        "status": order.status,
        "created_at": order.created_at.isoformat()
    } for order in orders]), 200


# http://127.0.0.1:5000/get_all_orders

# curl --location 'http://127.0.0.1:5000/get_all_orders' \
# --header 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc0NDg3MzczMSwianRpIjoiYzA1NTRkYWYtZDM1OS00OTM4LWJiYzMtMWM4MzFkOTZiNjNiIiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjEwIiwibmJmIjoxNzQ0ODczNzMxLCJjc3JmIjoiNjdmNDY0NWItZDJmMy00YWQzLTljNTYtOTVmMDVmZDlmYTFiIiwiZXhwIjoxNzQ0OTYwMTMxfQ.ocuYi2Hi7rt39SN0sRTkPb3VqHeT7xWfthC3ApH9Flc'



@order_bp.route("/update_status/<int:order_id>", methods=["PUT"])
@jwt_required()
def update_order_status(order_id):
    user_id = get_jwt_identity()
    user = User.query.get(user_id)

    if user.role != "admin":
        return jsonify({"error": "Unauthorized"}), 403

    order = Order.query.get(order_id)
    if not order:
        return jsonify({"error": "Order not found"}), 404

    data = request.get_json()
    new_status = data.get("status")

    valid_statuses = ["Pending", "Processing", "Out_for_delivery", "Delivered", "Cancelled", "Returned"]

    if new_status not in valid_statuses:
        return jsonify({"error": f"Invalid status '{new_status}'"}), 400

    order.status = new_status
    db.session.commit()

    return jsonify({"message": f"Order status updated to '{new_status}'"}), 200



    --------------------

init.py
from flask import Flask
from flask_cors import CORS
from flask_jwt_extended import JWTManager
from flask_migrate import Migrate 
from app.config import Config 
from app.models import db


app = Flask(__name__)
CORS(app)
app.config.from_object(Config)

db.init_app(app)
jwt = JWTManager(app)
migrate = Migrate(app, db) 


from app.order import order_bp
from app.auth import auth_bp  
from app.product import product_bp
from app.admin import admin_bp
from app.cart import cart_bp
from app.address import address_bp

app.register_blueprint(order_bp)
app.register_blueprint(address_bp)
app.register_blueprint(auth_bp, url_prefix='/auth')
app.register_blueprint(product_bp)
app.register_blueprint(admin_bp, url_prefix='/admin')
app.register_blueprint(cart_bp)


if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)

-----------------------------

address.py 
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models import db, Address

address_bp = Blueprint('address', __name__)

# Add new address
@address_bp.route('/add_new_address', methods=['POST'])
@jwt_required()
def add_address():
    user_id = get_jwt_identity()
    data = request.get_json() or {}

    required_fields = ['street', 'city', 'state', 'zip_code', 'country']
    if not all(field in data and data[field].strip() for field in required_fields):
        return jsonify({"error": "All address fields are required"}), 400

    new_address = Address(
        user_id=user_id,
        street=data['street'].strip(),
        city=data['city'].strip(),
        state=data['state'].strip(),
        zip_code=data['zip_code'].strip(),
        country=data['country'].strip()
    )
    db.session.add(new_address)
    db.session.commit()

    return jsonify({"message": "Address added successfully", "address_id": new_address.id}), 201

# http://127.0.0.1:5000/add_new_address

# {
#   "street": "Near dmart, Ambegaon",
#   "city": "Pune",
#   "state": "Maharashtra",
#   "zip_code": "442200",
#   "country": "India"
# }



# Get all addresses of the logged-in user
@address_bp.route('/getall_addresses', methods=['GET'])
@jwt_required()
def get_user_addresses():
    user_id = get_jwt_identity()
    addresses = Address.query.filter_by(user_id=user_id).all()

    result = []
    for addr in addresses:
        result.append({
            "id": addr.id,
            "street": addr.street,
            "city": addr.city,
            "state": addr.state,
            "zip_code": addr.zip_code,
            "country": addr.country
        })

    return jsonify({"addresses": result}), 200

# http://127.0.0.1:5000/getall_addresses




# Update an address
@address_bp.route('/update_address/<int:address_id>', methods=['PUT'])
@jwt_required()
def update_address(address_id):
    user_id = get_jwt_identity()
    address = Address.query.filter_by(id=address_id, user_id=user_id).first()

    if not address:
        return jsonify({"error": "Address not found or unauthorized"}), 404

    data = request.get_json() or {}

    # Only update if a field is provided
    address.street = data.get('street', address.street)
    address.city = data.get('city', address.city)
    address.state = data.get('state', address.state)
    address.zip_code = data.get('zip_code', address.zip_code)
    address.country = data.get('country', address.country)

    db.session.commit()

    return jsonify({"message": "Address updated successfully"}), 200

# http://127.0.0.1:5000/update_address/1

# {
#     "city":"Navi Mumbai"
# }






# Delete an address
@address_bp.route('/delete_address/<int:address_id>', methods=['DELETE'])
@jwt_required()
def delete_address(address_id):
    user_id = get_jwt_identity()
    address = Address.query.filter_by(id=address_id, user_id=user_id).first()

    if not address:
        return jsonify({"error": "Address not found or unauthorized"}), 404

    db.session.delete(address)
    db.session.commit()
    return jsonify({"message": "Address deleted successfully"}), 200


# http://127.0.0.1:5000/delete_address/1



-------------------------------------
admin.py 


from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models import db, User,Product,Order
from app import app  





# User Management:

admin_bp = Blueprint('admin', __name__)

def is_admin(user_id):
    user = User.query.get(user_id)
    return user and user.role == "admin"

# (register admin) is in auth.py


# Get all users
@admin_bp.route('/users', methods=['GET'])
@jwt_required()
def get_all_users():
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    users = User.query.all()
    user_list = []
    for user in users:
        user_data = {
            "id": user.id,
            "name": user.name,
            "email": user.email,
            "role": user.role,
        }
        user_list.append(user_data)
    return jsonify({"users": user_list}), 200
# http://127.0.0.1:5000/admin/users



# display user details
@admin_bp.route('/users/<int:user_id>', methods=['GET'])
@jwt_required()
def user_details(user_id):
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    user = User.query.get(user_id)
    if not user:
        return jsonify({"error": "User not found"}), 404

    user_data = {
        "id": user.id,
        "name": user.name,
        "email": user.email,
        "role": user.role,
    }
    return jsonify({"user": user_data}), 200
# http://127.0.0.1:5000/admin/users/5


# update user role
@admin_bp.route('/users/<int:user_id>/promote', methods=['PUT'])
@jwt_required()
def promote_user(user_id):
    current_user_id = get_jwt_identity()

    # Ensure only an admin can promote another user
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    user = User.query.get(user_id)
    if not user:
        return jsonify({"error": "User not found"}), 404

    # Promote the user to admin
    user.role = "admin"

    db.session.commit()
    return jsonify({"message": f"User {user_id} has been promoted to admin."}), 200
# http://127.0.0.1:5000/admin/users/8/promote



# delete a user
@admin_bp.route('/users/<int:user_id>', methods=['DELETE'])
@jwt_required()
def delete_user(user_id):
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    user = User.query.get(user_id)
    if not user:
        return jsonify({"error": "User not found"}), 404

    db.session.delete(user)
    db.session.commit()
    return jsonify({"message": "User deleted successfully"}), 200
# http://127.0.0.1:5000/admin/users/8

  
# Product Management:



# Add Products
def add_product():
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    data = request.get_json() or {}
    name = data.get('name', "").strip()
    description = data.get('description', "").strip()
    price = data.get('price')
    stock = data.get('stock', 0)
    category = data.get('category', "").strip()
    image_url = data.get('image_url', "").strip()

    # Basic validation: required fields
    if not name or price is None or not category:
        return jsonify({"error": "Missing required product details"}), 400

    new_product = Product(
        name=name,
        description=description,
        price=price,
        stock=stock,
        category=category,
        image_url=image_url
    )
    db.session.add(new_product)
    db.session.commit()

    return jsonify({"message": "Product added successfully", "product_id": new_product.id}), 201





# List Products

@admin_bp.route('/products', methods=['GET'])
@jwt_required()
def list_products():
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    products = Product.query.all()
    product_list = []
    for product in products:
        product_list.append({
            "id": product.id,
            "name": product.name,
            "description": product.description,
            "price": product.price,
            "stock": product.stock,
            "category": product.category,
            "image_url": product.image_url
        })
    return jsonify({"products": product_list}), 200
# http://127.0.0.1:5000/admin/products


# Get product details
@admin_bp.route('/products/<int:product_id>', methods=['GET'])
@jwt_required()
def product_details(product_id):
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    product = Product.query.get(product_id)
    if not product:
        return jsonify({"error": "Product not found"}), 404

    product_data = {
        "id": product.id,
        "name": product.name,
        "description": product.description,
        "price": product.price,
        "stock": product.stock,
        "category": product.category,
        "image_url": product.image_url
    }
    return jsonify({"product": product_data}), 200
# http://127.0.0.1:5000/admin/products/3

# Update Product details

@admin_bp.route('/products/<int:product_id>', methods=['PUT'])
@jwt_required()
def update_product(product_id):
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    product = Product.query.get(product_id)
    if not product:
        return jsonify({"error": "Product not found"}), 404

    data = request.get_json() or {}
    # Update fields if present in the request
    if 'name' in data:
        product.name = data.get('name').strip()
    if 'description' in data:
        product.description = data.get('description').strip()
    if 'price' in data:
        product.price = data.get('price')
    if 'stock' in data:
        product.stock = data.get('stock')
    if 'category' in data:
        product.category = data.get('category').strip()
    if 'image_url' in data:
        product.image_url = data.get('image_url').strip()

    db.session.commit()
    return jsonify({"message": "Product updated successfully"}), 200


# Delete Product

@admin_bp.route('/products/<int:product_id>', methods=['DELETE'])
@jwt_required()
def delete_product(product_id):
    current_user_id = get_jwt_identity()
    if not is_admin(current_user_id):
        return jsonify({"error": "Unauthorized"}), 403

    product = Product.query.get(product_id)
    if not product:
        return jsonify({"error": "Product not found"}), 404

    db.session.delete(product)
    db.session.commit()
    return jsonify({"message": "Product deleted successfully"}), 200

# 
--------------------------
auth.py 

from app import app
from flask import Blueprint, request, jsonify
from werkzeug.security import generate_password_hash, check_password_hash
from flask_jwt_extended import create_access_token, jwt_required, get_jwt_identity,create_refresh_token
from datetime import timedelta
from app.models import db, User
import jwt
# from config import Config


auth_bp = Blueprint('auth', __name__)

#register
@auth_bp.route('/register', methods=['POST'])
def register():
    data = request.get_json() or {}

    name = data.get('name', "").strip()
    email = data.get('email', "").strip().lower()
    phone = data.get('phone', "").strip()
    password = data.get('password', "").strip()
    role = data.get("role", "user")

    if not name or not email or not password or not phone:
        return jsonify({"error": "All fields are required"}), 400

    if User.query.filter_by(email=email).first():
        return jsonify({"error": "Email already registered"}), 409
    if User.query.filter_by(phone=phone).first():
        return jsonify({"error": "Phone number already exists"}), 400

    hashed_password = generate_password_hash(password)
    new_user = User(name=name, email=email, phone=phone, password=hashed_password, role=role)
    
    db.session.add(new_user)
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        print("Error committing to the database:", e)
        return jsonify({"error": "Database error"}), 500

    return jsonify({"message": "User registered successfully"}), 201

# if we want to implement flsk for specific routes

# from flask import Flask, request, jsonify
# from flask_cors import cross_origin

# app = Flask(__name__)

# @app.route('/auth/register', methods=['POST'])
# @cross_origin(origin='http://localhost:5173')  # Allow requests from React frontend
# def register():
#     data = request.json
#     return jsonify({"message": "User registered successfully"}), 200




# Register admin

@auth_bp.route('/register-admin', methods=['POST'])
def register_admin():
    data = request.get_json() or {}

    name = data.get('name', "").strip()
    email = data.get('email', "").strip().lower()
    phone = data.get('phone', "").strip()
    password = data.get('password', "").strip()

    if not name or not email or not password or not phone:
        return jsonify({"error": "All fields are required"}), 400

    if User.query.filter_by(email=email).first():
        return jsonify({"error": "Email already registered"}), 409
    if User.query.filter_by(phone=phone).first():
        return jsonify({"error": "Phone number already exists"}), 400

    hashed_password = generate_password_hash(password)
    new_admin = User(name=name, email=email, phone=phone, password=hashed_password, role="admin")

    db.session.add(new_admin)
    try:
        db.session.commit()
    except Exception as e:
        db.session.rollback()
        print("Error committing to the database:", e)
        return jsonify({"error": "Database error"}), 500

    return jsonify({"message": "Admin registered successfully"}), 201


#generated token
def generate_token(user):
    payload = {
        "id": user.id,
        "email": user.email,
        "role": user.role,  
        # "exp": datetime.datetime.utcnow() + datetime.timedelta(hours=1)
    }
    secret_key = app.config.get("SECRET_KEY", "your_default_secret")
    return jwt.encode(payload, secret_key, algorithm="HS256")



#Login
@auth_bp.route('/login', methods=['POST'])
def login():
    data = request.get_json() or {}

    email = data.get('email', "").strip().lower()
    password = data.get('password', "").strip()

    user = User.query.filter_by(email=email).first()

    if not user or not check_password_hash(user.password, password):
        return jsonify({"error": "Invalid credentials"}), 401

    access_token = create_access_token(identity=str(user.id), expires_delta=timedelta(days=1))
    refresh_token = create_refresh_token(identity=str(user.id))

    return jsonify({
        "message": "Login successful",
        "access_token": access_token,
        "user": {
            "id": user.id,
            "name": user.name,
            "email": user.email,
            "role": user.role
        }
    }), 200



# password change
@auth_bp.route('/change-password', methods=['PUT'])
@jwt_required()
def change_password():
    data = request.get_json() or {}
    current_password = data.get('current_password', "").strip()
    new_password = data.get('new_password', "").strip()

    if not current_password or not new_password:
        return jsonify({"error": "Both current and new passwords are required"}), 400

    user_id = get_jwt_identity()
    user = User.query.get(user_id)
    
    if not user or not check_password_hash(user.password, current_password):
        return jsonify({"error": "Current password is incorrect"}), 401

    if len(new_password) < 8:
        return jsonify({"error": "New password must be at least 8 characters long"}), 400

    user.password = generate_password_hash(new_password)
    db.session.commit()

    return jsonify({"message": "Password changed successfully"}), 200



#Logout
@auth_bp.route('/logout', methods=['POST'])
@jwt_required()
def logout():
    return jsonify({"message": "Logout successful."}), 200


----------------------------------

cart.py 



from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app import db
from app.models import Cart, Product

cart_bp = Blueprint('cart', __name__)










@cart_bp.route('/cart/add', methods=['POST'])
@jwt_required()
def add_to_cart():
    data = request.get_json()
    print("Received data:", data)
    if not data:
        return jsonify({'message': 'Invalid JSON payload'}), 422

    # Get the user_id from the JWT token
    user_id = get_jwt_identity()

    try:
        product_id = int(data.get('product_id'))
    except (TypeError, ValueError):
        return jsonify({'message': 'Product ID must be a valid integer'}), 422

    try:
        quantity = int(data.get('quantity', 1))
    except (TypeError, ValueError):
        return jsonify({'message': 'Quantity must be a valid integer'}), 422

    if not product_id:
        return jsonify({'message': 'Product ID is required'}), 400

    product = Product.query.get(product_id)
    if not product:
        return jsonify({'message': 'Product not found'}), 404

    if product.stock < quantity:
        return jsonify({'message': 'Insufficient stock available'}), 400

    # Check if the product already exists in the user's cart.
    cart_item = Cart.query.filter_by(user_id=user_id, product_id=product_id).first()
    if cart_item:
        cart_item.quantity += quantity
    else:
        new_cart_item = Cart(user_id=user_id, product_id=product_id, quantity=quantity)
        db.session.add(new_cart_item)

    db.session.commit()
    return jsonify({'message': 'Item added to cart'}), 201



@cart_bp.route('/update_cart_quantity', methods=['POST'])
@jwt_required()
def update_cart_quantity():
    user_id = get_jwt_identity()
    data = request.get_json()

    product_id = data.get('product_id')
    quantity = data.get('quantity')

    if not product_id or quantity is None:
        return jsonify({'message': 'Product ID and quantity are required'}), 400

    try:
        product_id = int(product_id)
        quantity = int(quantity)
    except ValueError:
        return jsonify({'message': 'Invalid product ID or quantity'}), 400

    cart_item = Cart.query.filter_by(user_id=user_id, product_id=product_id).first()
    if not cart_item:
        return jsonify({'message': 'Item not found in cart'}), 404

    if quantity < 1:
        db.session.delete(cart_item)
    else:
        cart_item.quantity = quantity

    db.session.commit()
    return jsonify({'message': 'Cart updated successfully'}), 200




@cart_bp.route('/cart/remove/<int:cart_id>', methods=['DELETE'])
@jwt_required()
def remove_from_cart(cart_id):
    user_id = get_jwt_identity()
    cart_item = Cart.query.filter_by(id=cart_id, user_id=user_id).first()

    if not cart_item:
        return jsonify({'message': 'Cart item not found'}), 404

    db.session.delete(cart_item)
    db.session.commit()
    return jsonify({'message': 'Item removed from cart'}), 200

@cart_bp.route('/cart/update', methods=['PUT'])
@jwt_required()
def update_cart():
    data = request.get_json()
    user_id = get_jwt_identity()
    cart_id = data.get('cart_id')
    quantity = data.get('quantity')

    if cart_id is None or quantity is None:
        return jsonify({'message': 'cart_id and quantity are required'}), 400

    cart_item = Cart.query.filter_by(id=cart_id, user_id=user_id).first()
    if not cart_item:
        return jsonify({'message': 'Cart item not found'}), 404

    if quantity <= 0:
        db.session.delete(cart_item)
        message = 'Item removed from cart'
    else:
        if cart_item.product.stock < quantity:
            return jsonify({'message': 'Insufficient stock for the desired quantity'}), 400
        cart_item.quantity = quantity
        message = 'Cart updated successfully'

    db.session.commit()
    return jsonify({'message': message}), 200




@cart_bp.route('/cart/view', methods=['GET', 'OPTIONS'])
def view_cart():
    if request.method == 'OPTIONS':
        return jsonify({'message': 'CORS preflight'}), 200 


    from flask_jwt_extended import jwt_required, get_jwt_identity

    @jwt_required()
    def get_cart():
        user_id = get_jwt_identity()
        cart_items = Cart.query.filter_by(user_id=user_id).all()

        cart_data = []
        for item in cart_items:
            cart_data.append({
                'cart_id': item.id,
                'product_id': item.product_id,
                'product_name': item.product.name,
                'quantity': item.quantity,
                'price': item.product.price,
                'total_price': item.quantity * item.product.price,
                'added_at': item.created_at.isoformat(),
                'image_url': item.product.image_url or ""

            })

        return jsonify(cart_data), 200

    return get_cart()




-------------------------------

inventory.py 
from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app import db
from app.models import Cart, Product

cart_bp = Blueprint('cart', __name__)










@cart_bp.route('/cart/add', methods=['POST'])
@jwt_required()
def add_to_cart():
    data = request.get_json()
    print("Received data:", data)
    if not data:
        return jsonify({'message': 'Invalid JSON payload'}), 422

    # Get the user_id from the JWT token
    user_id = get_jwt_identity()

    try:
        product_id = int(data.get('product_id'))
    except (TypeError, ValueError):
        return jsonify({'message': 'Product ID must be a valid integer'}), 422

    try:
        quantity = int(data.get('quantity', 1))
    except (TypeError, ValueError):
        return jsonify({'message': 'Quantity must be a valid integer'}), 422

    if not product_id:
        return jsonify({'message': 'Product ID is required'}), 400

    product = Product.query.get(product_id)
    if not product:
        return jsonify({'message': 'Product not found'}), 404

    if product.stock < quantity:
        return jsonify({'message': 'Insufficient stock available'}), 400

    # Check if the product already exists in the user's cart.
    cart_item = Cart.query.filter_by(user_id=user_id, product_id=product_id).first()
    if cart_item:
        cart_item.quantity += quantity
    else:
        new_cart_item = Cart(user_id=user_id, product_id=product_id, quantity=quantity)
        db.session.add(new_cart_item)

    db.session.commit()
    return jsonify({'message': 'Item added to cart'}), 201



@cart_bp.route('/update_cart_quantity', methods=['POST'])
@jwt_required()
def update_cart_quantity():
    user_id = get_jwt_identity()
    data = request.get_json()

    product_id = data.get('product_id')
    quantity = data.get('quantity')

    if not product_id or quantity is None:
        return jsonify({'message': 'Product ID and quantity are required'}), 400

    try:
        product_id = int(product_id)
        quantity = int(quantity)
    except ValueError:
        return jsonify({'message': 'Invalid product ID or quantity'}), 400

    cart_item = Cart.query.filter_by(user_id=user_id, product_id=product_id).first()
    if not cart_item:
        return jsonify({'message': 'Item not found in cart'}), 404

    if quantity < 1:
        db.session.delete(cart_item)
    else:
        cart_item.quantity = quantity

    db.session.commit()
    return jsonify({'message': 'Cart updated successfully'}), 200




@cart_bp.route('/cart/remove/<int:cart_id>', methods=['DELETE'])
@jwt_required()
def remove_from_cart(cart_id):
    user_id = get_jwt_identity()
    cart_item = Cart.query.filter_by(id=cart_id, user_id=user_id).first()

    if not cart_item:
        return jsonify({'message': 'Cart item not found'}), 404

    db.session.delete(cart_item)
    db.session.commit()
    return jsonify({'message': 'Item removed from cart'}), 200

@cart_bp.route('/cart/update', methods=['PUT'])
@jwt_required()
def update_cart():
    data = request.get_json()
    user_id = get_jwt_identity()
    cart_id = data.get('cart_id')
    quantity = data.get('quantity')

    if cart_id is None or quantity is None:
        return jsonify({'message': 'cart_id and quantity are required'}), 400

    cart_item = Cart.query.filter_by(id=cart_id, user_id=user_id).first()
    if not cart_item:
        return jsonify({'message': 'Cart item not found'}), 404

    if quantity <= 0:
        db.session.delete(cart_item)
        message = 'Item removed from cart'
    else:
        if cart_item.product.stock < quantity:
            return jsonify({'message': 'Insufficient stock for the desired quantity'}), 400
        cart_item.quantity = quantity
        message = 'Cart updated successfully'

    db.session.commit()
    return jsonify({'message': message}), 200




@cart_bp.route('/cart/view', methods=['GET', 'OPTIONS'])
def view_cart():
    if request.method == 'OPTIONS':
        return jsonify({'message': 'CORS preflight'}), 200 


    from flask_jwt_extended import jwt_required, get_jwt_identity

    @jwt_required()
    def get_cart():
        user_id = get_jwt_identity()
        cart_items = Cart.query.filter_by(user_id=user_id).all()

        cart_data = []
        for item in cart_items:
            cart_data.append({
                'cart_id': item.id,
                'product_id': item.product_id,
                'product_name': item.product.name,
                'quantity': item.quantity,
                'price': item.product.price,
                'total_price': item.quantity * item.product.price,
                'added_at': item.created_at.isoformat(),
                'image_url': item.product.image_url or ""

            })

        return jsonify(cart_data), 200

    return get_cart()




----------------------------------

product.py 

from flask import Blueprint, request, jsonify,send_from_directory
from app.models import db, Product
import os
from werkzeug.utils import secure_filename
from app import app, db
from flask_jwt_extended import jwt_required


product_bp = Blueprint('product', __name__)


UPLOAD_FOLDER = os.path.abspath(os.path.join(app.root_path,'img'))
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER







# Get all products
@product_bp.route('/get_all_products', methods=['GET'])
def get_products():
    products = Product.query.all()
    return jsonify([product.to_dict() for product in products]), 200

# Get a single product by ID
@product_bp.route('/get_product/<int:id>', methods=['GET'])
def get_product(id):
    product = Product.query.get(id)
    if not product:
        return jsonify({"error": "Product not found"}), 404
    return jsonify(product.to_dict()), 200

from sqlalchemy.sql.expression import func

@product_bp.route('/get_random_products', methods=['GET'])
def get_random_products():
    products = Product.query.order_by(func.random()).limit(10).all()
    return jsonify([product.to_dict() for product in products]), 200



# Get products based on category
@product_bp.route('/category/filter', methods=['GET'])
def filter_products_by_category():
    category = request.args.get('category')
    if not category:
        return jsonify({"message": "Please provide a category to filter"}), 400
    products = Product.query.filter_by(category=category).all()
    return jsonify([product.to_dict() for product in products]), 200

FIXED_CATEGORIES = ["Fruits", "Vegetables", "Dairy"]


@product_bp.route('/add_product', methods=['POST'])
@jwt_required()
def add_product():
    data = request.get_json()

    # Extract fields from JSON
    name = data.get('name')
    description = data.get('description', "")
    price = data.get('price')
    unit = data.get('unit')
    stock = data.get('stock')
    category = data.get('category')

    # Validate required fields
    if not all([name, price, unit, stock, category]):
        return jsonify({"error": "Missing required fields"}), 400

    if category not in FIXED_CATEGORIES:
        return jsonify({"error": f"Invalid category. Choose from {FIXED_CATEGORIES}"}), 400

    try:
        price = float(price)
        stock = int(stock)
    except ValueError:
        return jsonify({"error": "Price must be a float and stock must be an integer"}), 400

    # Create product instance (no image)
    new_product = Product(
        name=name,
        description=description,
        price=price,
        unit=unit,
        stock=stock,
        category=category,
        image_url=""  
    )

    db.session.add(new_product)
    db.session.commit()

    return jsonify({
        "message": "Product added successfully",
        "product": new_product.to_dict()
    }), 201






# Update a product (Admin Only)
@product_bp.route('/update_product/<int:id>', methods=['PUT'])
@jwt_required()
def update_product(id):
    product = Product.query.get(id)
    if not product:
        return jsonify({"error": "Product not found"}), 404

    data = request.get_json()
    
    product.name = data.get('name', product.name)
    product.description = data.get('description', product.description)
    product.price = data.get('price', product.price)
    product.unit = data.get('unit', product.unit)
    product.stock = data.get('stock', product.stock)
    product.category = data.get('category', product.category)
    product.image_url = data.get('image_url', product.image_url)


    db.session.commit()
    return jsonify({"message": "Product updated successfully"}), 200

# Delete a product (Admin Only)
@product_bp.route('/delete_product/<int:id>', methods=['DELETE'])
@jwt_required()
def delete_product(id):
    product = Product.query.get(id)
    if not product:
        return jsonify({"error": "Product not found"}), 404

    db.session.delete(product)
    db.session.commit()
    return jsonify({"message": "Product deleted successfully"}), 200


@product_bp.route('/upload_image/<int:product_id>', methods=['POST'])
@jwt_required()
def upload_product_image(product_id):
    product = Product.query.get(product_id)

    if not product:
        return jsonify({"error": "Product not found"}), 404

    if 'image' not in request.files:
        return jsonify({"error": "No file part"}), 400

    file = request.files['image']

    if file.filename == '':
        return jsonify({"error": "No selected file"}), 400

    filename = secure_filename(file.filename)
    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)

    file.save(filepath)

    product.image_url = f"img/{filename}"
    db.session.commit()

    return jsonify({
        "message": "Image uploaded successfully",
        "image_url": product.image_url
    }), 200




@app.route('/img/<filename>')
def serve_image(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename)





-------------------




run.py 


from app import app





if __name__ == "__main__":
    
    print("Starting Flask app.. ") 
    app.run(debug=True)



----------------------------
runner.py



from flask import Blueprint, request, jsonify
from flask_jwt_extended import jwt_required, get_jwt_identity
from app.models import db, User, Order, RunnerAssignments
from datetime import datetime

runner_bp = Blueprint('runner', __name__,)

def is_admin(user_id):
    u = User.query.get(user_id)
    return u and u.role == 'admin'

# 1️⃣ Promote an existing user to Runner (or create a fresh Runner)
@runner_bp.route('/promote/<int:user_id>', methods=['PUT'])
@jwt_required()
def promote_to_runner(user_id):
    admin_id = get_jwt_identity()
    if not is_admin(admin_id):
        return jsonify({"error": "Unauthorized"}), 403

    user = User.query.get(user_id)
    if not user:
        return jsonify({"error": "User not found"}), 404

    user.role = 'runner'
    db.session.commit()
    return jsonify({"message": f"User {user.name} is now a Runner."}), 200

# 2️⃣ Update Runner info (name, email, phone)
@runner_bp.route('/<int:runner_id>', methods=['PUT'])
@jwt_required()
def update_runner_info(runner_id):
    admin_id = get_jwt_identity()
    if not is_admin(admin_id):
        return jsonify({"error": "Unauthorized"}), 403

    runner = User.query.filter_by(id=runner_id, role='runner').first()
    if not runner:
        return jsonify({"error": "Runner not found"}), 404

    data = request.get_json() or {}
    for fld in ['name','email','phone']:
        if fld in data:
            setattr(runner, fld, data[fld].strip())
    db.session.commit()
    return jsonify({"message": "Runner info updated"}), 200

# 3️⃣ Toggle Runner active/inactive (ban/unban)
@runner_bp.route('/<int:runner_id>/active', methods=['PUT'])
@jwt_required()
def set_runner_active(runner_id):
    admin_id = get_jwt_identity()
    if not is_admin(admin_id):
        return jsonify({"error": "Unauthorized"}), 403

    runner = User.query.filter_by(id=runner_id, role='runner').first()
    if not runner:
        return jsonify({"error": "Runner not found"}), 404

    data = request.get_json() or {}
    if 'is_active' not in data:
        return jsonify({"error": "is_active required"}), 400

    runner.is_active = bool(data['is_active'])
    db.session.commit()
    status = "activated" if runner.is_active else "banned"
    return jsonify({"message": f"Runner {status}."}), 200

# 4️⃣ Assign a Runner to an Order
@runner_bp.route('/assign', methods=['POST'])
@jwt_required()
def assign_runner():
    admin_id = get_jwt_identity()
    if not is_admin(admin_id):
        return jsonify({"error": "Unauthorized"}), 403

    data = request.get_json() or {}
    order_id = data.get('order_id')
    runner_id = data.get('runner_id')
    if not order_id or not runner_id:
        return jsonify({"error": "order_id and runner_id required"}), 400

    # Validate
    order = Order.query.get(order_id)
    runner = User.query.filter_by(id=runner_id, role='runner', is_active=True).first()
    if not order:
        return jsonify({"error": "Order not found"}), 404
    if not runner:
        return jsonify({"error": "Runner not available"}), 404

    # Check runner free (no open assignment)
    open_assign = RunnerAssignments.query.filter_by(
        runner_id=runner_id
    ).filter(RunnerAssignments.status.in_(['assigned','picked_up'])).first()
    if open_assign:
        return jsonify({"error": "Runner is currently engaged"}), 400

    # Create assignment
    ra = RunnerAssignments(order_id=order_id, runner_id=runner_id)
    db.session.add(ra)
    db.session.commit()
    return jsonify({"message": f"Runner {runner.name} assigned to order {order.id}"}), 201
@runner_bp.route('/assignment/<int:assign_id>', methods=['PUT'])
@jwt_required()
def update_assignment(assign_id):
    user_id = get_jwt_identity()
    user    = User.query.get(user_id)
    ra      = RunnerAssignments.query.get(assign_id)
    if not ra:
        return jsonify({"error": "Assignment not found"}), 404
    if user.role != 'admin' and ra.runner_id != user_id:
        return jsonify({"error": "Unauthorized"}), 403

    data = request.get_json() or {}
    new_status = data.get('status')
    if new_status not in ['assigned','picked_up','delivered','cancelled']:
        return jsonify({"error": "Invalid status"}), 400

    # Explicit updates
    if new_status == 'picked_up':
        ra.picked_up_at    = datetime.utcnow()
        ra.status         = 'picked_up'
        ra.order.status   = 'Out_for_delivery'
    elif new_status == 'delivered':
        ra.delivered_at   = datetime.utcnow()
        ra.status         = 'delivered'
        ra.order.status   = 'Delivered'
    elif new_status == 'cancelled':
        ra.status         = 'cancelled'
        ra.order.status   = 'Cancelled'
    else:
        ra.status = 'assigned'

    db.session.commit()
    return jsonify({"message": f"Assignment and order marked '{new_status}'"}), 200




# 6️⃣ List Runners by Engagement
@runner_bp.route('/get_runner_list', methods=['GET'])
@jwt_required()
def list_runners():
    # optional filter ?status=free|engaged
    status = request.args.get('status')
    base = User.query.filter_by(role='runner', is_active=True)
    runners = []
    for r in base:
        open_assign = RunnerAssignments.query.filter_by(
            runner_id=r.id
        ).filter(RunnerAssignments.status.in_(['assigned','picked_up'])).first()
        engaged = bool(open_assign)
        if status=='free' and engaged:   continue
        if status=='engaged' and not engaged:   continue
        runners.append({
            "id": r.id,
            "name": r.name,
            "email": r.email,
            "phone": r.phone,
            "engaged": engaged
        })
    return jsonify(runners), 200








@runner_bp.route('/<int:runner_id>/history', methods=['GET'])
@jwt_required()
def get_runner_history(runner_id):
 
    current_user_id = get_jwt_identity()
    current = User.query.get(current_user_id)
    # only the runner themself or an admin can view
    if not (current.role == 'admin' or current.id == runner_id):
        return jsonify({"error": "Unauthorized"}), 403

    assignments = RunnerAssignments\
        .query\
        .filter_by(runner_id=runner_id)\
        .order_by(RunnerAssignments.assigned_at.desc())\
        .all()

    history = []
    for a in assignments:
        order = Order.query.get(a.order_id)
        history.append({
            "assignment_id":     a.id,
            "order_id":          a.order_id,
            "order_status":      order.status,
            "order_created_at":  order.created_at.isoformat(),
            "total_price":       order.total_price,
            "assigned_at":       a.assigned_at.isoformat(),
            "picked_up_at":      a.picked_up_at.isoformat() if a.picked_up_at else None,
            "delivered_at":      a.delivered_at.isoformat() if a.delivered_at else None,
            "assignment_status": a.status
        })

    return jsonify(history), 200































